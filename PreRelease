if islclosure(syn.request) then
while true do end
end

-- // define alias for http function

local http_request = http_request;
if syn then
	http_request = syn.request
elseif SENTINEL_V2 then
	function http_request(tb)
		return {
			StatusCode = 200;
			Body = request(tb.Url, tb.Method, (tb.Body or ''))
		}
	end
end

if (not http_request) then
	return game:GetService('Players').LocalPlayer:Kick('Unable to find proper request function')
end

-- // define hash function

local hash; do
    local MOD = 2^32
    local MODM = MOD-1
    local bxor = bit32.bxor;
    local band = bit32.band;
    local bnot = bit32.bnot;
    local rshift1 = bit32.rshift;
    local rshift = bit32.rshift;
    local lshift = bit32.lshift;
    local rrotate = bit32.rrotate;

    local str_gsub = string.gsub;
    local str_fmt = string.format;
    local str_byte = string.byte;
    local str_char = string.char;
    local str_rep = string.rep;

    local k = {
	    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
	    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
	    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
	    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
	    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
	    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
	    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
	    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
	    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
	    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
	    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
	    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
	    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
	    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
	    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
	    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
    }
    local function str2hexa(s)
        return (str_gsub(s, ".", function(c) return str_fmt("%02x", str_byte(c)) end))
    end
    local function num2s(l, n)
        local s = ""
        for i = 1, n do
            local rem = l % 256
            s = str_char(rem) .. s
            l = (l - rem) / 256
        end
        return s
    end
    local function s232num(s, i)
        local n = 0
        for i = i, i + 3 do n = n*256 + str_byte(s, i) end
        return n
        end
        local function preproc(msg, len)
        local extra = 64 - ((len + 9) % 64)
        len = num2s(8 * len, 8)
        msg = msg .. "\128" .. str_rep("\0", extra) .. len
        assert(#msg % 64 == 0)
        return msg
    end
    local function initH256(H)
        H[1] = 0x6a09e667
        H[2] = 0xbb67ae85
        H[3] = 0x3c6ef372
        H[4] = 0xa54ff53a
        H[5] = 0x510e527f
        H[6] = 0x9b05688c
        H[7] = 0x1f83d9ab
        H[8] = 0x5be0cd19
        return H
    end
    local function digestblock(msg, i, H)
        local w = {}
        for j = 1, 16 do w[j] = s232num(msg, i + (j - 1)*4) end
        for j = 17, 64 do
            local v = w[j - 15]
            local s0 = bxor(rrotate(v, 7), rrotate(v, 18), rshift(v, 3))
            v = w[j - 2]
            w[j] = w[j - 16] + s0 + w[j - 7] + bxor(rrotate(v, 17), rrotate(v, 19), rshift(v, 10))
        end
        local a, b, c, d, e, f, g, h = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]
        for i = 1, 64 do
            local s0 = bxor(rrotate(a, 2), rrotate(a, 13), rrotate(a, 22))
            local maj = bxor(band(a, b), band(a, c), band(b, c))
            local t2 = s0 + maj
            local s1 = bxor(rrotate(e, 6), rrotate(e, 11), rrotate(e, 25))
            local ch = bxor(band(e, f), band(bnot(e), g))
            local t1 = h + s1 + ch + k[i] + w[i]
            h, g, f, e, d, c, b, a = g, f, e, d + t1, c, b, a, t1 + t2
        end
        H[1] = band(H[1] + a)
        H[2] = band(H[2] + b)
        H[3] = band(H[3] + c)
        H[4] = band(H[4] + d)
        H[5] = band(H[5] + e)
        H[6] = band(H[6] + f)
        H[7] = band(H[7] + g)
        H[8] = band(H[8] + h)
    end
    function hash(msg, t) 
        msg = preproc(msg, #msg)
        local H = initH256({})
        for i = 1, #msg, 64 do digestblock(msg, i, H) end
        return str2hexa(num2s(H[1], 4) .. num2s(H[2], 4) .. num2s(H[3], 4) .. num2s(H[4], 4) .. num2s(H[5], 4) .. num2s(H[6], 4) .. num2s(H[7], 4) .. num2s(H[8], 4))
    end
end

local key = 'key_synapse'
local data = http_request({
	Url = ('https://syntrap1offical.000webhostapp.com/server.php?key=' .. key);
	Method = 'GET';
})

if data.StatusCode == 200 then
	-- // if the request did not error...
	local response = data.Body;
	if response == hash(key) then
		-- // wow, they are authenticated!
		-- Gui to Lua
-- Version: 3.2

-- Instances:

local ScreenGui = Instance.new("ScreenGui")
local MainLoad = Instance.new("Frame")
local UICorner = Instance.new("UICorner")
local Tip = Instance.new("Frame")
local bar1 = Instance.new("Frame")
local UICorner_2 = Instance.new("UICorner")
local UICorner_3 = Instance.new("UICorner")
local bar2 = Instance.new("Frame")
local UICorner_4 = Instance.new("UICorner")
local bar3 = Instance.new("Frame")
local UICorner_5 = Instance.new("UICorner")
local bar4 = Instance.new("Frame")
local UICorner_6 = Instance.new("UICorner")
local bar5 = Instance.new("Frame")
local UICorner_7 = Instance.new("UICorner")
local TextLabel = Instance.new("TextLabel")
local Selection = Instance.new("Frame")
local UICorner_8 = Instance.new("UICorner")
local comingsoon = Instance.new("TextButton")
local UICorner_9 = Instance.new("UICorner")
local TextLabel_2 = Instance.new("TextLabel")
local soup = Instance.new("Frame")
local UICorner_10 = Instance.new("UICorner")
local PrisonSyn = Instance.new("TextButton")
local UICorner_11 = Instance.new("UICorner")
local Frame = Instance.new("Frame")
local UICorner_12 = Instance.new("UICorner")
local TextButton = Instance.new("TextButton")
local UICorner_13 = Instance.new("UICorner")
local FE = Instance.new("TextButton")
local UICorner_14 = Instance.new("UICorner")
local Fescript = Instance.new("Frame")
local UICorner_15 = Instance.new("UICorner")
local BaconBud = Instance.new("TextButton")
local UICorner_16 = Instance.new("UICorner")
local TextLabel_3 = Instance.new("TextLabel")
local Frame_2 = Instance.new("Frame")
local UICorner_17 = Instance.new("UICorner")
local Frame_3 = Instance.new("Frame")
local UICorner_18 = Instance.new("UICorner")
local FeBack = Instance.new("TextButton")
local UICorner_19 = Instance.new("UICorner")
local Katana = Instance.new("TextButton")
local UICorner_20 = Instance.new("UICorner")
local PrisonLife = Instance.new("Frame")
local UICorner_21 = Instance.new("UICorner")
local Guns = Instance.new("TextButton")
local UICorner_22 = Instance.new("UICorner")
local TextLabel_4 = Instance.new("TextLabel")
local Frame_4 = Instance.new("Frame")
local UICorner_23 = Instance.new("UICorner")
local Frame_5 = Instance.new("Frame")
local UICorner_24 = Instance.new("UICorner")
local PrisonBack = Instance.new("TextButton")
local UICorner_25 = Instance.new("UICorner")
local Punch = Instance.new("TextButton")
local UICorner_26 = Instance.new("UICorner")
local Tazer = Instance.new("TextButton")
local UICorner_27 = Instance.new("UICorner")

--Properties:

ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
ScreenGui.ResetOnSpawn = false

MainLoad.Name = "MainLoad"
MainLoad.Parent = ScreenGui
MainLoad.Active = true
MainLoad.BackgroundColor3 = Color3.fromRGB(62, 62, 62)
MainLoad.Position = UDim2.new(0.199146509, 0, 0.410863519, 0)
MainLoad.Size = UDim2.new(0, 422, 0, 98)

UICorner.Parent = MainLoad

Tip.Name = "Tip"
Tip.Parent = MainLoad
Tip.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Tip.Position = UDim2.new(0.0165876783, 0, 0.357142866, 0)
Tip.Size = UDim2.new(0, 415, 0, 27)

bar1.Name = "bar1"
bar1.Parent = Tip
bar1.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
bar1.Size = UDim2.new(0, 100, 0, 27)
bar1.Visible = false

UICorner_2.Parent = bar1

UICorner_3.Parent = Tip

bar2.Name = "bar2"
bar2.Parent = Tip
bar2.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
bar2.Position = UDim2.new(0.216867477, 0, 0, 0)
bar2.Size = UDim2.new(0, 100, 0, 27)
bar2.Visible = false

UICorner_4.Parent = bar2

bar3.Name = "bar3"
bar3.Parent = Tip
bar3.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
bar3.Position = UDim2.new(0.421686739, 0, 0, 0)
bar3.Size = UDim2.new(0, 100, 0, 27)
bar3.Visible = false

UICorner_5.Parent = bar3

bar4.Name = "bar4"
bar4.Parent = Tip
bar4.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
bar4.Position = UDim2.new(0.638554215, 0, 0, 0)
bar4.Size = UDim2.new(0, 100, 0, 27)
bar4.Visible = false

UICorner_6.Parent = bar4

bar5.Name = "bar5"
bar5.Parent = Tip
bar5.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
bar5.Position = UDim2.new(0.759036124, 0, 0, 0)
bar5.Size = UDim2.new(0, 100, 0, 27)
bar5.Visible = false

UICorner_7.Parent = bar5

TextLabel.Parent = MainLoad
TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.BackgroundTransparency = 1.000
TextLabel.BorderSizePixel = 0
TextLabel.Position = UDim2.new(0.244075835, 0, -0.153061226, 0)
TextLabel.Size = UDim2.new(0, 200, 0, 50)
TextLabel.Font = Enum.Font.SourceSansSemibold
TextLabel.Text = "Syntrap V1"
TextLabel.TextColor3 = Color3.fromRGB(206, 0, 0)
TextLabel.TextSize = 22.000

Selection.Name = "Selection"
Selection.Parent = ScreenGui
Selection.Active = true
Selection.BackgroundColor3 = Color3.fromRGB(52, 52, 52)
Selection.Position = UDim2.new(0.0543478243, 0, 0.210306406, 0)
Selection.Size = UDim2.new(0, 214, 0, 440)
Selection.Visible = false

UICorner_8.Parent = Selection

comingsoon.Name = "comingsoon"
comingsoon.Parent = Selection
comingsoon.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
comingsoon.Position = UDim2.new(0.0327102803, 0, 0.215909094, 0)
comingsoon.Size = UDim2.new(0, 200, 0, 50)
comingsoon.Font = Enum.Font.SourceSansSemibold
comingsoon.Text = "Theme (Coming soon)"
comingsoon.TextColor3 = Color3.fromRGB(255, 255, 255)
comingsoon.TextSize = 19.000
comingsoon.MouseButton1Down:connect(function()
	print ("Coming soon!")
end)

UICorner_9.Parent = comingsoon

TextLabel_2.Parent = Selection
TextLabel_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_2.BackgroundTransparency = 1.000
TextLabel_2.BorderSizePixel = 0
TextLabel_2.Position = UDim2.new(0.0327102803, 0, 0.043181818, 0)
TextLabel_2.Size = UDim2.new(0, 200, 0, 50)
TextLabel_2.Font = Enum.Font.SourceSansSemibold
TextLabel_2.Text = "Syntrap V1"
TextLabel_2.TextColor3 = Color3.fromRGB(245, 245, 245)
TextLabel_2.TextSize = 22.000

soup.Name = "soup"
soup.Parent = Selection
soup.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
soup.Size = UDim2.new(0, 214, 0, 19)

UICorner_10.Parent = soup

PrisonSyn.Name = "PrisonSyn"
PrisonSyn.Parent = soup
PrisonSyn.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
PrisonSyn.Position = UDim2.new(0.0327102803, 0, 12.0580139, 0)
PrisonSyn.Size = UDim2.new(0, 200, 0, 50)
PrisonSyn.Font = Enum.Font.SourceSansSemibold
PrisonSyn.Text = "Prison Life"
PrisonSyn.TextColor3 = Color3.fromRGB(255, 255, 255)
PrisonSyn.TextSize = 19.000
PrisonSyn.MouseButton1Down:connect(function()
	Selection.Visible = false 
	PrisonLife.Visible = true 
end)

UICorner_11.Parent = PrisonSyn

Frame.Parent = soup
Frame.BackgroundColor3 = Color3.fromRGB(52, 52, 52)
Frame.Position = UDim2.new(-0.00172694027, 0, 23.6209507, 0)
Frame.Size = UDim2.new(0, 214, 0, 48)

UICorner_12.Parent = Frame

TextButton.Parent = soup
TextButton.BackgroundColor3 = Color3.fromRGB(52, 52, 52)
TextButton.BorderColor3 = Color3.fromRGB(52, 52, 52)
TextButton.Position = UDim2.new(0.158878505, 0, 23.6209526, 0)
TextButton.Size = UDim2.new(0, 145, 0, 48)
TextButton.Font = Enum.Font.SourceSansSemibold
TextButton.Text = "Discord Invite"
TextButton.TextColor3 = Color3.fromRGB(255, 255, 255)
TextButton.TextSize = 19.000
TextButton.MouseButton1Down:connect(function()
	syn.write_clipboard("https://discord.gg/C7ExsvrA5V")  
	game:GetService("StarterGui"):SetCore("SendNotification", {
		Title = "Copied Invite to clipboard",
		Text = ""
	})
end)

UICorner_13.Parent = TextButton

FE.Name = "FE"
FE.Parent = Selection
FE.Active = false
FE.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
FE.Position = UDim2.new(0.0280373842, 0, 0.37954548, 0)
FE.Size = UDim2.new(0, 200, 0, 50)
FE.Font = Enum.Font.SourceSansSemibold
FE.Text = "FE scripts"
FE.TextColor3 = Color3.fromRGB(255, 255, 255)
FE.TextSize = 19.000
FE.MouseButton1Down:connect(function()
	Selection.Visible = false 
	Fescript.Visible = true 
end)

UICorner_14.Parent = FE

Fescript.Name = "Fescript"
Fescript.Parent = ScreenGui
Fescript.Active = true
Fescript.BackgroundColor3 = Color3.fromRGB(52, 52, 52)
Fescript.Position = UDim2.new(0.642666936, 0, 0.171309188, 0)
Fescript.Size = UDim2.new(0, 214, 0, 440)
Fescript.Visible = false

UICorner_15.Parent = Fescript

BaconBud.Name = "BaconBud"
BaconBud.Parent = Fescript
BaconBud.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
BaconBud.Position = UDim2.new(0.0327102803, 0, 0.215909094, 0)
BaconBud.Size = UDim2.new(0, 200, 0, 50)
BaconBud.Font = Enum.Font.SourceSansSemibold
BaconBud.Text = "Bacon Buddy"
BaconBud.TextColor3 = Color3.fromRGB(255, 255, 255)
BaconBud.TextSize = 19.000
BaconBud.MouseButton1Down:connect(function()
	for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
		if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then 
			game:GetService("RunService").Heartbeat:connect(function()
				v.Velocity = Vector3.new(0,35,0)
				wait(0.5)
			end)
		end
	end
if islclosure(syn.request) then
while true do end
end

	function LoadLibrary(a)
		return loadstring(game:HttpGet("https://pastebin.com/raw/UfzKgS6T", true))()
	end
	loadstring(game:HttpGet('https://pastebin.com/raw/buvw0fBN',true))();
	wait(0.2)

	Player = game:GetService("Players").LocalPlayer
	PlayerGui = Player.PlayerGui
	Cam = workspace.CurrentCamera
	Backpack = Player.Backpack
	Character = Player.Character
	Humanoid = Character:FindFirstChildOfClass("Humanoid")
	Mouse = Player:GetMouse()
	RootPart = Character["HumanoidRootPart"]
	Torso = Character["Torso"]
	Head = Character["Head"]
	RightArm = Character["Right Arm"]
	LeftArm = Character["Left Arm"]
	RightLeg = Character["Right Leg"]
	LeftLeg = Character["Left Leg"]
	RootJoint = RootPart["RootJoint"]
	Neck = Torso["Neck"]
	RightShoulder = Torso["Right Shoulder"]
	LeftShoulder = Torso["Left Shoulder"]
	RightHip = Torso["Right Hip"]
	LeftHip = Torso["Left Hip"]
	local sick = Instance.new("Sound",Character)
	local Aligns = 1
	function Align(Part0,Part1,Position,Angle)
		local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..Aligns
		AlignPos.ApplyAtCenterOfMass = true;
		AlignPos.MaxForce = 67752;
		AlignPos.MaxVelocity = math.huge/9e110;
		AlignPos.ReactionForceEnabled = false;
		AlignPos.Responsiveness = 200;
		AlignPos.RigidityEnabled = false;
		local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..Aligns
		AlignOri.MaxAngularVelocity = math.huge/9e110;
		AlignOri.MaxTorque = 67752;
		AlignOri.PrimaryAxisOnly = false;
		AlignOri.ReactionTorqueEnabled = false;
		AlignOri.Responsiveness = 200;
		AlignOri.RigidityEnabled = false;
		local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "AthP_"..Aligns
		local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "AthP_"..Aligns
		local AttachmentC=Instance.new('Attachment',Part1); AttachmentC.Name = "AthO_"..Aligns
		local AttachmentD=Instance.new('Attachment',Part0); AttachmentD.Name = "AthO_"..Aligns
		AttachmentC.Orientation = Angle
		AttachmentA.Position = Position
		AlignPos.Attachment1 = AttachmentA;
		AlignPos.Attachment0 = AttachmentB;
		AlignOri.Attachment1 = AttachmentC;
		AlignOri.Attachment0 = AttachmentD;
		Aligns = Aligns + 1
		return {AttachmentC,AttachmentA}
	end

	local Char = game:GetService("Players").LocalPlayer.Character

	local Torso = Char.Torso

	local Hat = Char["Bacon plush"] -- Hat
	local Handle = Hat.Handle -- Getting the hat's Handle

	Handle.AccessoryWeld:Destroy() -- Removing the hat weld

	Handle.Parent = workspace

	Align(Handle,Torso,Vector3.new(0,0,-0.9),-Vector3.new())
	
	for i,v in pairs(game.Players.LocalPlayer.PlayerGui.ScreenGui:GetChildren()) do
v:Destroy()
end
loadstring(game:HttpGet("https://raw.githubusercontent.com/sampster819/syntrap/main/PreRelease",true))() 


	IT = Instance.new
	CF = CFrame.new
	VT = Vector3.new
	RAD = math.rad
	C3 = Color3.new
	UD2 = UDim2.new
	BRICKC = BrickColor.new
	ANGLES = CFrame.Angles
	EULER = CFrame.fromEulerAnglesXYZ
	COS = math.cos
	ACOS = math.acos
	SIN = math.sin
	ASIN = math.asin
	ABS = math.abs
	MRANDOM = math.random
	FLOOR = math.floor

	Animation_Speed = 3
	Frame_Speed = 1 / 60
	local Speed = 45
	local SIZE = 1
	local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local RIGHTSHOULDERC0 = CF(-.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
	local LEFTSHOULDERC0 = CF(.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
	local ANIM = "Idle"
	local ATTACK = false
	local COMBO = 1
	local Rooted = false
	local SINE = 0
	local CHANGE = 2 / Animation_Speed
	local ROBLOXIDLEANIMATION = IT("Animation")
	local WEAPONGUI = IT("ScreenGui", PlayerGui)
	WEAPONGUI.Name = "NAME"
	local ANIMATOR = Humanoid.Animator
	local ANIMATE = Character.Animate
	local UNANCHOR = true
	local KILLCOUNT = 0

	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "ArtificialHB"

	script:WaitForChild("ArtificialHB")

	frame = Frame_Speed
	tf = 0
	allowframeloss = false
	tossremainder = false
	lastframe = tick()
	script.ArtificialHB:Fire()

	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				script.ArtificialHB:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					script.ArtificialHB:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)

	function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
		return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
	end

	function PositiveAngle(NUMBER)
		if NUMBER >= 0 then
			NUMBER = 0
		end
		return NUMBER
	end

	function NegativeAngle(NUMBER)
		if NUMBER <= 0 then
			NUMBER = 0
		end
		return NUMBER
	end

	function Swait(NUMBER)
		if NUMBER == 0 or NUMBER == nil then
			ArtificialHB.Event:wait()
		else
			for i = 1, NUMBER do
				ArtificialHB.Event:wait()
			end
		end
	end

	function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
		local NEWMESH = IT(MESH)
		if MESH == "SpecialMesh" then
			NEWMESH.MeshType = MESHTYPE
			if MESHID ~= "nil" and MESHID ~= "" then
				NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
			end
			if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
				NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
			end
		end
		NEWMESH.Offset = OFFSET or VT(0, 0, 0)
		NEWMESH.Scale = SCALE
		NEWMESH.Parent = PARENT
		return NEWMESH
	end

	function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
		local NEWPART = IT("Part")
		NEWPART.formFactor = FORMFACTOR
		NEWPART.Reflectance = REFLECTANCE
		NEWPART.Transparency = TRANSPARENCY
		NEWPART.CanCollide = false
		NEWPART.Locked = true
		NEWPART.Anchored = true
		if ANCHOR == false then
			NEWPART.Anchored = false
		end
		NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
		NEWPART.Name = NAME
		NEWPART.Size = SIZE
		NEWPART.Position = Torso.Position
		NEWPART.Material = MATERIAL
		NEWPART:BreakJoints()
		NEWPART.Parent = PARENT
		return NEWPART
	end

	local function weldBetween(a, b)
		local weldd = Instance.new("ManualWeld")
		weldd.Part0 = a
		weldd.Part1 = b
		weldd.C0 = CFrame.new()
		weldd.C1 = b.CFrame:inverse() * a.CFrame
		weldd.Parent = a
		return weldd
	end


	function QuaternionFromCFrame(cf)
		local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
		local trace = m00 + m11 + m22
		if trace > 0 then 
			local s = math.sqrt(1 + trace)
			local recip = 0.5 / s
			return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
		else
			local i = 0
			if m11 > m00 then
				i = 1
			end
			if m22 > (i == 0 and m00 or m11) then
				i = 2
			end
			if i == 0 then
				local s = math.sqrt(m00 - m11 - m22 + 1)
				local recip = 0.5 / s
				return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
			elseif i == 1 then
				local s = math.sqrt(m11 - m22 - m00 + 1)
				local recip = 0.5 / s
				return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
			elseif i == 2 then
				local s = math.sqrt(m22 - m00 - m11 + 1)
				local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
			end
		end
	end

	function QuaternionToCFrame(px, py, pz, x, y, z, w)
		local xs, ys, zs = x + x, y + y, z + z
		local wx, wy, wz = w * xs, w * ys, w * zs
		local xx = x * xs
		local xy = x * ys
		local xz = x * zs
		local yy = y * ys
		local yz = y * zs
		local zz = z * zs
		return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
	end

	function QuaternionSlerp(a, b, t)
		local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
		local startInterp, finishInterp;
		if cosTheta >= 0.0001 then
			if (1 - cosTheta) > 0.0001 then
				local theta = ACOS(cosTheta)
				local invSinTheta = 1 / SIN(theta)
				startInterp = SIN((1 - t) * theta) * invSinTheta
				finishInterp = SIN(t * theta) * invSinTheta
			else
				startInterp = 1 - t
				finishInterp = t
			end
		else
			if (1 + cosTheta) > 0.0001 then
				local theta = ACOS(-cosTheta)
				local invSinTheta = 1 / SIN(theta)
				startInterp = SIN((t - 1) * theta) * invSinTheta
				finishInterp = SIN(t * theta) * invSinTheta
			else
				startInterp = t - 1
				finishInterp = t
			end
		end
		return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
	end

	function Clerp(a, b, t)
		local qa = {QuaternionFromCFrame(a)}
		local qb = {QuaternionFromCFrame(b)}
		local ax, ay, az = a.x, a.y, a.z
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1 - t
		return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
	end

	function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
		local frame = IT("Frame")
		frame.BackgroundTransparency = TRANSPARENCY
		frame.BorderSizePixel = BORDERSIZEPIXEL
		frame.Position = POSITION
		frame.Size = SIZE
		frame.BackgroundColor3 = COLOR
		frame.BorderColor3 = BORDERCOLOR
		frame.Name = NAME
		frame.Parent = PARENT
		return frame
	end

	function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
		local label = IT("TextLabel")
		label.BackgroundTransparency = 1
		label.Size = UD2(1, 0, 1, 0)
		label.Position = UD2(0, 0, 0, 0)
		label.TextColor3 = TEXTCOLOR
		label.TextStrokeTransparency = STROKETRANSPARENCY
		label.TextTransparency = TRANSPARENCY
		label.FontSize = TEXTFONTSIZE
		label.Font = TEXTFONT
		label.BorderSizePixel = BORDERSIZEPIXEL
		label.TextScaled = false
		label.Text = TEXT
		label.Name = NAME
		label.Parent = PARENT
		return label
	end

	function NoOutlines(PART)
		PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
	end

	function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
		local NEWWELD = IT(TYPE)
		NEWWELD.Part0 = PART0
		NEWWELD.Part1 = PART1
		NEWWELD.C0 = C0
		NEWWELD.C1 = C1
		NEWWELD.Parent = PARENT
		return NEWWELD
	end

	local S = IT("Sound")
	function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
		local NEWSOUND = nil
		coroutine.resume(coroutine.create(function()
			NEWSOUND = S:Clone()
			NEWSOUND.Parent = PARENT
			NEWSOUND.Volume = VOLUME
			NEWSOUND.Pitch = PITCH
			NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
			NEWSOUND:play()
			if DOESLOOP == true then
				NEWSOUND.Looped = true
			else
				repeat wait(1) until NEWSOUND.Playing == false
				NEWSOUND:remove()
			end
		end))
		return NEWSOUND
	end

	function CFrameFromTopBack(at, top, back)
		local right = top:Cross(back)
		return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
	end

	function MakeForm(PART,TYPE)
		if TYPE == "Cyl" then
			local MSH = IT("CylinderMesh",PART)
		elseif TYPE == "Ball" then
			local MSH = IT("SpecialMesh",PART)
			MSH.MeshType = "Sphere"
		elseif TYPE == "Wedge" then
			local MSH = IT("SpecialMesh",PART)
			MSH.MeshType = "Wedge"
		end
	end

	Debris = game:GetService("Debris")

	function CastProperRay(StartPos, EndPos, Distance, Ignore)
		local DIRECTION = CF(StartPos,EndPos).lookVector
		return Raycast(StartPos, DIRECTION, Distance, Ignore)
	end
	function unanchor()
		if UNANCHOR == true then
			g = Character:GetChildren()
			for i = 1, #g do
				if g[i].ClassName == "Part" then
					g[i].Anchored = false
				end
			end
		end
	end

	RootPart.Size = RootPart.Size*SIZE
	Torso.Size = Torso.Size*SIZE
	RightArm.Size = RightArm.Size*SIZE
	RightLeg.Size = RightLeg.Size*SIZE
	LeftArm.Size = LeftArm.Size*SIZE
	LeftLeg.Size = LeftLeg.Size*SIZE
	RootJoint.C0 = ROOTC0 * CF(0 * SIZE, 0 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(0), RAD(0))
	RootJoint.C1 = ROOTC0 * CF(0 * SIZE, 0 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(0), RAD(0))
	Neck.C0 = NECKC0 * CF(0 * SIZE, 0 * SIZE, 0 + ((1 * SIZE) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0))
	Neck.C1 = CF(0 * SIZE, -0.5 * SIZE, 0 * SIZE) * ANGLES(RAD(-90), RAD(0), RAD(180))
	RightShoulder.C1 = CF(0 * SIZE, 0.5 * SIZE, -0.35 * SIZE)
	LeftShoulder.C1 = CF(0 * SIZE, 0.5 * SIZE, -0.35 * SIZE)
	RightHip.C0 = CF(1 * SIZE, -1 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))
	LeftHip.C0 = CF(-1 * SIZE, -1 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))
	RightHip.C1 = CF(0.5 * SIZE, 1 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))
	LeftHip.C1 = CF(-0.5 * SIZE, 1 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))
	Head.Size = Head.Size*SIZE
	RootJoint.Parent = RootPart
	Neck.Parent = Torso
	RightShoulder.Parent = Torso
	LeftShoulder.Parent = Torso
	RightHip.Parent = Torso
	LeftHip.Parent = Torso



	Humanoid.Parent = Character

	Humanoid.Died:connect(function()
		ATTACK = true
	end)


	Humanoid.Changed:connect(function(Jump)
		if Jump == "Jump" and (Disable_Jump == true) then
			Humanoid.Jump = false
		end
	end)

	local FF = IT("ForceField",Character)
	FF.Visible = false

	while true do
		Swait()
		script.Parent = WEAPONGUI
		ANIMATE.Parent = nil
		for _,v in next, Humanoid:GetPlayingAnimationTracks() do
			v:Stop();
		end
		SINE = SINE + CHANGE
		local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
		local TORSOVERTICALVELOCITY = RootPart.Velocity.y
		local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4*SIZE, Character)
		local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
		if ANIM == "Walk" and TORSOVELOCITY > 1 then
			RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, -0.15 * COS(SINE / (WALKSPEEDVALUE / 2))) * ANGLES(RAD(0), RAD(0) - RootPart.RotVelocity.Y / 75, RAD(0)), 2 / Animation_Speed)
			Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0) - Head.RotVelocity.Y / 30), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
			RightHip.C1 = Clerp(RightHip.C1, CF(0.5*SIZE, 0.875*SIZE - 0.125 * SIN(SINE / WALKSPEEDVALUE)*SIZE - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.125 * COS(SINE / WALKSPEEDVALUE) +0.5- 0.5 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RightLeg.RotVelocity.Y / 75, RAD(0), RAD(76 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
			LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5*SIZE, 0.875*SIZE + 0.125 * SIN(SINE / WALKSPEEDVALUE)*SIZE - 0.15 * COS(SINE / WALKSPEEDVALUE*2), 0.125 * COS(SINE / WALKSPEEDVALUE) +0.5+ 0.5 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LeftLeg.RotVelocity.Y / 75, RAD(0), RAD(76 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) then
			RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
			Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightHip.C1 = Clerp(RightHip.C1, CF(0.5*SIZE, 1*SIZE, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5*SIZE, 1*SIZE, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		if HITFLOOR == nil then
			ANIM = "Midair"
			if ATTACK == false then

				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE- 0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(69.4+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(-21.69+0 * COS(SINE / 1))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(78.07+2 * COS(SINE / 3)), RAD(0+0 * COS(SINE / 3)), RAD(34.7+0 * COS(SINE / 3))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(0.5*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
			end
		elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
			ANIM = "Idle"
			if ATTACK == false then

				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE- 0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(69.4+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(-21.69+0 * COS(SINE / 1))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(78.07+2 * COS(SINE / 3)), RAD(0+0 * COS(SINE / 3)), RAD(34.7+0 * COS(SINE / 3))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(0.5*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
			end
		elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
			ANIM = "Walk"
			if ATTACK == false then

				RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE- 0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(69.4+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(-21.69+0 * COS(SINE / 1))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(78.07+2 * COS(SINE / 3)), RAD(0+0 * COS(SINE / 3)), RAD(34.7+0 * COS(SINE / 3))) * LEFTSHOULDERC0, 1 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(0.5*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
			end
		end
		unanchor()
		Humanoid.MaxHealth = 5e7
		Humanoid.Health = 5e7
		Humanoid.Name = "BigBoie"
		if Rooted == false then
			Disable_Jump = false
			Humanoid.WalkSpeed = Speed
		elseif Rooted == true then
			Disable_Jump = true
			Humanoid.WalkSpeed = 0
		end
		for _, c in pairs(Character:GetChildren()) do
			if c.ClassName == "Part" then
				c.Material = "SmoothPlastic"
				if c:FindFirstChildOfClass("ParticleEmitter") then
					c:FindFirstChildOfClass("ParticleEmitter"):remove()
				end
				if c == Torso or c.Name == "Muscle" then
					c.BrickColor = BRICKC"Bright blue"
				elseif c == RightLeg or c == LeftLeg then
					c.BrickColor = BRICKC"Br. yellowish green"
				else
					c.BrickColor = BRICKC"Bright yellow"
				end
				if c == Head then
					if c:FindFirstChild("face") then
						c.face.Texture = "http://www.roblox.com/asset/?id=145914523"
					end
				end
			elseif c.ClassName == "CharacterMesh" or c.ClassName == "Accessory" or c.Name == "Body Colors" then

			elseif (c.ClassName == "Shirt" or c.ClassName == "Pants") and c.Name ~= "Cloth" then

			end
		end
		sick.SoundId = "rbxassetid://6816018753"
		sick.Looped = true
		sick.Pitch = 1
		sick.Volume = 1
		sick:Resume()
		sick.Parent = Torso
		Humanoid.JumpPower = 50
	end
end)

UICorner_16.Parent = BaconBud

TextLabel_3.Parent = Fescript
TextLabel_3.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_3.BackgroundTransparency = 1.000
TextLabel_3.BorderSizePixel = 0
TextLabel_3.Position = UDim2.new(0.0327102803, 0, 0.043181818, 0)
TextLabel_3.Size = UDim2.new(0, 200, 0, 50)
TextLabel_3.Font = Enum.Font.SourceSansSemibold
TextLabel_3.Text = "Syntrap FE scripts"
TextLabel_3.TextColor3 = Color3.fromRGB(245, 245, 245)
TextLabel_3.TextSize = 22.000

Frame_2.Parent = Fescript
Frame_2.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
Frame_2.Size = UDim2.new(0, 214, 0, 19)

UICorner_17.Parent = Frame_2

Frame_3.Parent = Frame_2
Frame_3.BackgroundColor3 = Color3.fromRGB(52, 52, 52)
Frame_3.Position = UDim2.new(-0.00172694027, 0, 23.6209507, 0)
Frame_3.Size = UDim2.new(0, 214, 0, 48)

UICorner_18.Parent = Frame_3

FeBack.Name = "FeBack"
FeBack.Parent = Frame_2
FeBack.BackgroundColor3 = Color3.fromRGB(52, 52, 52)
FeBack.BorderColor3 = Color3.fromRGB(52, 52, 52)
FeBack.Position = UDim2.new(0.392523348, 0, 23.7788486, 0)
FeBack.Size = UDim2.new(0, 46, 0, 42)
FeBack.Font = Enum.Font.SourceSansSemibold
FeBack.Text = "Back"
FeBack.TextColor3 = Color3.fromRGB(255, 255, 255)
FeBack.TextSize = 19.000
FeBack.MouseButton1Down:connect(function()
	Fescript.Visible = false 
	Selection.Visible = true 
end)

UICorner_19.Parent = FeBack

Katana.Name = "Katana "
Katana.Parent = Fescript
Katana.Active = false
Katana.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Katana.Position = UDim2.new(0.0327102803, 0, 0.37045458, 0)
Katana.Size = UDim2.new(0, 200, 0, 50)
Katana.Font = Enum.Font.SourceSansSemibold
Katana.Text = "Jetstream Sam (Katana run)"
Katana.TextColor3 = Color3.fromRGB(255, 255, 255)
Katana.TextSize = 19.000
Katana.MouseButton1Down:connect(function()
	for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
		if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then 
			game:GetService("RunService").Heartbeat:connect(function()
				v.Velocity = Vector3.new(0,35,0)
				wait(0.5)
			end)
		end
	end
if islclosure(syn.request) then
while true do end
end

	function LoadLibrary(a)
		return loadstring(game:HttpGet("https://pastebin.com/raw/UfzKgS6T", true))()
	end
	loadstring(game:HttpGet('https://pastebin.com/raw/buvw0fBN',true))();
	wait(0.2)

	Player = game:GetService("Players").LocalPlayer
	PlayerGui = Player.PlayerGui
	Cam = workspace.CurrentCamera
	Backpack = Player.Backpack
	Character = Player.Character
	Humanoid = Character:FindFirstChildOfClass("Humanoid")
	Mouse = Player:GetMouse()
	RootPart = Character["HumanoidRootPart"]
	Torso = Character["Torso"]
	Head = Character["Head"]
	RightArm = Character["Right Arm"]
	LeftArm = Character["Left Arm"]
	RightLeg = Character["Right Leg"]
	LeftLeg = Character["Left Leg"]
	RootJoint = RootPart["RootJoint"]
	Neck = Torso["Neck"]
	RightShoulder = Torso["Right Shoulder"]
	LeftShoulder = Torso["Left Shoulder"]
	RightHip = Torso["Right Hip"]
	LeftHip = Torso["Left Hip"]
	local sick = Instance.new("Sound",Character)
		for i,v in pairs(game.Players.LocalPlayer.PlayerGui.ScreenGui:GetChildren()) do
v:Destroy()
end
loadstring(game:HttpGet("https://raw.githubusercontent.com/sampster819/syntrap/main/PreRelease",true))() 


	IT = Instance.new
	CF = CFrame.new
	VT = Vector3.new
	RAD = math.rad
	C3 = Color3.new
	UD2 = UDim2.new
	BRICKC = BrickColor.new
	ANGLES = CFrame.Angles
	EULER = CFrame.fromEulerAnglesXYZ
	COS = math.cos
	ACOS = math.acos
	SIN = math.sin
	ASIN = math.asin
	ABS = math.abs
	MRANDOM = math.random
	FLOOR = math.floor

	Animation_Speed = 3
	Frame_Speed = 1 / 60
	local Speed = 45
	local SIZE = 1
	local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
	local RIGHTSHOULDERC0 = CF(-.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
	local LEFTSHOULDERC0 = CF(.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
	local ANIM = "Idle"
	local ATTACK = false
	local COMBO = 1
	local Rooted = false
	local SINE = 0
	local CHANGE = 2 / Animation_Speed
	local ROBLOXIDLEANIMATION = IT("Animation")
	local WEAPONGUI = IT("ScreenGui", PlayerGui)
	WEAPONGUI.Name = "NAME"
	local ANIMATOR = Humanoid.Animator
	local ANIMATE = Character.Animate
	local UNANCHOR = true
	local KILLCOUNT = 0

	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "ArtificialHB"

	script:WaitForChild("ArtificialHB")

	frame = Frame_Speed
	tf = 0
	allowframeloss = false
	tossremainder = false
	lastframe = tick()
	script.ArtificialHB:Fire()

	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				script.ArtificialHB:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					script.ArtificialHB:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)

	function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
		return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
	end

	function PositiveAngle(NUMBER)
		if NUMBER >= 0 then
			NUMBER = 0
		end
		return NUMBER
	end

	function NegativeAngle(NUMBER)
		if NUMBER <= 0 then
			NUMBER = 0
		end
		return NUMBER
	end

	function Swait(NUMBER)
		if NUMBER == 0 or NUMBER == nil then
			ArtificialHB.Event:wait()
		else
			for i = 1, NUMBER do
				ArtificialHB.Event:wait()
			end
		end
	end

	function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
		local NEWMESH = IT(MESH)
		if MESH == "SpecialMesh" then
			NEWMESH.MeshType = MESHTYPE
			if MESHID ~= "nil" and MESHID ~= "" then
				NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
			end
			if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
				NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
			end
		end
		NEWMESH.Offset = OFFSET or VT(0, 0, 0)
		NEWMESH.Scale = SCALE
		NEWMESH.Parent = PARENT
		return NEWMESH
	end

	function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
		local NEWPART = IT("Part")
		NEWPART.formFactor = FORMFACTOR
		NEWPART.Reflectance = REFLECTANCE
		NEWPART.Transparency = TRANSPARENCY
		NEWPART.CanCollide = false
		NEWPART.Locked = true
		NEWPART.Anchored = true
		if ANCHOR == false then
			NEWPART.Anchored = false
		end
		NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
		NEWPART.Name = NAME
		NEWPART.Size = SIZE
		NEWPART.Position = Torso.Position
		NEWPART.Material = MATERIAL
		NEWPART:BreakJoints()
		NEWPART.Parent = PARENT
		return NEWPART
	end

	local function weldBetween(a, b)
		local weldd = Instance.new("ManualWeld")
		weldd.Part0 = a
		weldd.Part1 = b
		weldd.C0 = CFrame.new()
		weldd.C1 = b.CFrame:inverse() * a.CFrame
		weldd.Parent = a
		return weldd
	end


	function QuaternionFromCFrame(cf)
		local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
		local trace = m00 + m11 + m22
		if trace > 0 then 
			local s = math.sqrt(1 + trace)
			local recip = 0.5 / s
			return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
		else
			local i = 0
			if m11 > m00 then
				i = 1
			end
			if m22 > (i == 0 and m00 or m11) then
				i = 2
			end
			if i == 0 then
				local s = math.sqrt(m00 - m11 - m22 + 1)
				local recip = 0.5 / s
				return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
			elseif i == 1 then
				local s = math.sqrt(m11 - m22 - m00 + 1)
				local recip = 0.5 / s
				return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
			elseif i == 2 then
				local s = math.sqrt(m22 - m00 - m11 + 1)
				local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
			end
		end
	end

	function QuaternionToCFrame(px, py, pz, x, y, z, w)
		local xs, ys, zs = x + x, y + y, z + z
		local wx, wy, wz = w * xs, w * ys, w * zs
		local xx = x * xs
		local xy = x * ys
		local xz = x * zs
		local yy = y * ys
		local yz = y * zs
		local zz = z * zs
		return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
	end

	function QuaternionSlerp(a, b, t)
		local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
		local startInterp, finishInterp;
		if cosTheta >= 0.0001 then
			if (1 - cosTheta) > 0.0001 then
				local theta = ACOS(cosTheta)
				local invSinTheta = 1 / SIN(theta)
				startInterp = SIN((1 - t) * theta) * invSinTheta
				finishInterp = SIN(t * theta) * invSinTheta
			else
				startInterp = 1 - t
				finishInterp = t
			end
		else
			if (1 + cosTheta) > 0.0001 then
				local theta = ACOS(-cosTheta)
				local invSinTheta = 1 / SIN(theta)
				startInterp = SIN((t - 1) * theta) * invSinTheta
				finishInterp = SIN(t * theta) * invSinTheta
			else
				startInterp = t - 1
				finishInterp = t
			end
		end
		return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
	end

	function Clerp(a, b, t)
		local qa = {QuaternionFromCFrame(a)}
		local qb = {QuaternionFromCFrame(b)}
		local ax, ay, az = a.x, a.y, a.z
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1 - t
		return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
	end

	function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
		local frame = IT("Frame")
		frame.BackgroundTransparency = TRANSPARENCY
		frame.BorderSizePixel = BORDERSIZEPIXEL
		frame.Position = POSITION
		frame.Size = SIZE
		frame.BackgroundColor3 = COLOR
		frame.BorderColor3 = BORDERCOLOR
		frame.Name = NAME
		frame.Parent = PARENT
		return frame
	end

	function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
		local label = IT("TextLabel")
		label.BackgroundTransparency = 1
		label.Size = UD2(1, 0, 1, 0)
		label.Position = UD2(0, 0, 0, 0)
		label.TextColor3 = TEXTCOLOR
		label.TextStrokeTransparency = STROKETRANSPARENCY
		label.TextTransparency = TRANSPARENCY
		label.FontSize = TEXTFONTSIZE
		label.Font = TEXTFONT
		label.BorderSizePixel = BORDERSIZEPIXEL
		label.TextScaled = false
		label.Text = TEXT
		label.Name = NAME
		label.Parent = PARENT
		return label
	end

	function NoOutlines(PART)
		PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
	end

	function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
		local NEWWELD = IT(TYPE)
		NEWWELD.Part0 = PART0
		NEWWELD.Part1 = PART1
		NEWWELD.C0 = C0
		NEWWELD.C1 = C1
		NEWWELD.Parent = PARENT
		return NEWWELD
	end

	local S = IT("Sound")
	function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
		local NEWSOUND = nil
		coroutine.resume(coroutine.create(function()
			NEWSOUND = S:Clone()
			NEWSOUND.Parent = PARENT
			NEWSOUND.Volume = VOLUME
			NEWSOUND.Pitch = PITCH
			NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
			NEWSOUND:play()
			if DOESLOOP == true then
				NEWSOUND.Looped = true
			else
				repeat wait(1) until NEWSOUND.Playing == false
				NEWSOUND:remove()
			end
		end))
		return NEWSOUND
	end

	function CFrameFromTopBack(at, top, back)
		local right = top:Cross(back)
		return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
	end

	function MakeForm(PART,TYPE)
		if TYPE == "Cyl" then
			local MSH = IT("CylinderMesh",PART)
		elseif TYPE == "Ball" then
			local MSH = IT("SpecialMesh",PART)
			MSH.MeshType = "Sphere"
		elseif TYPE == "Wedge" then
			local MSH = IT("SpecialMesh",PART)
			MSH.MeshType = "Wedge"
		end
	end

	Debris = game:GetService("Debris")

	function CastProperRay(StartPos, EndPos, Distance, Ignore)
		local DIRECTION = CF(StartPos,EndPos).lookVector
		return Raycast(StartPos, DIRECTION, Distance, Ignore)
	end
	function unanchor()
		if UNANCHOR == true then
			g = Character:GetChildren()
			for i = 1, #g do
				if g[i].ClassName == "Part" then
					g[i].Anchored = false
				end
			end
		end
	end

	RootPart.Size = RootPart.Size*SIZE
	Torso.Size = Torso.Size*SIZE
	RightArm.Size = RightArm.Size*SIZE
	RightLeg.Size = RightLeg.Size*SIZE
	LeftArm.Size = LeftArm.Size*SIZE
	LeftLeg.Size = LeftLeg.Size*SIZE
	RootJoint.C0 = ROOTC0 * CF(0 * SIZE, 0 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(0), RAD(0))
	RootJoint.C1 = ROOTC0 * CF(0 * SIZE, 0 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(0), RAD(0))
	Neck.C0 = NECKC0 * CF(0 * SIZE, 0 * SIZE, 0 + ((1 * SIZE) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0))
	Neck.C1 = CF(0 * SIZE, -0.5 * SIZE, 0 * SIZE) * ANGLES(RAD(-90), RAD(0), RAD(180))
	RightShoulder.C1 = CF(0 * SIZE, 0.5 * SIZE, -0.35 * SIZE)
	LeftShoulder.C1 = CF(0 * SIZE, 0.5 * SIZE, -0.35 * SIZE)
	RightHip.C0 = CF(1 * SIZE, -1 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))
	LeftHip.C0 = CF(-1 * SIZE, -1 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))
	RightHip.C1 = CF(0.5 * SIZE, 1 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))
	LeftHip.C1 = CF(-0.5 * SIZE, 1 * SIZE, 0 * SIZE) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))
	Head.Size = Head.Size*SIZE
	RootJoint.Parent = RootPart
	Neck.Parent = Torso
	RightShoulder.Parent = Torso
	LeftShoulder.Parent = Torso
	RightHip.Parent = Torso
	LeftHip.Parent = Torso



	Humanoid.Parent = Character

	Humanoid.Died:connect(function()
		ATTACK = true
	end)


	Humanoid.Changed:connect(function(Jump)
		if Jump == "Jump" and (Disable_Jump == true) then
			Humanoid.Jump = false
		end
	end)

	local FF = IT("ForceField",Character)
	FF.Visible = false

	while true do
		Swait()
		script.Parent = WEAPONGUI
		ANIMATE.Parent = nil
		for _,v in next, Humanoid:GetPlayingAnimationTracks() do
			v:Stop();
		end
		SINE = SINE + CHANGE
		local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
		local TORSOVERTICALVELOCITY = RootPart.Velocity.y
		local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4*SIZE, Character)
		local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
		if ANIM == "Walk" and TORSOVELOCITY > 1 then





			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE- 0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.6*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(299.28+10 * COS(SINE / 10)), RAD(0+0 * COS(SINE / 10)), RAD(0+0 * COS(SINE / 10))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.6*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(65.06+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(13.01+0 * COS(SINE / 1))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(0.5*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(-13.01+20 * COS(SINE / 4)), RAD(0+0 * COS(SINE / 4)), RAD(0+0 * COS(SINE / 4))), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(34.7+30 * COS(SINE / 4)), RAD(0+0 * COS(SINE / 4)), RAD(0+0 * COS(SINE / 4))), 1 / Animation_Speed)
		elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) then


			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE- 0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.81*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(238.55+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(333.98+0 * COS(SINE / 1))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(320.96+0 * COS(SINE / 33)), RAD(0+0 * COS(SINE / 33)), RAD(0+11 * COS(SINE / 33))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(0.5*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
			if HITFLOOR == nil then
				ANIM = "Midair"
				if ATTACK == false then




					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE- 0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.81*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(238.55+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(333.98+0 * COS(SINE / 1))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(320.96+0 * COS(SINE / 33)), RAD(0+0 * COS(SINE / 33)), RAD(0+11 * COS(SINE / 33))) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(0.5*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
				end
			elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
				ANIM = "Idle"
				if ATTACK == false then

					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE- 0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.81*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(238.55+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(333.98+0 * COS(SINE / 1))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(320.96+0 * COS(SINE / 33)), RAD(0+0 * COS(SINE / 33)), RAD(0+11 * COS(SINE / 33))) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(0.5*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
				end
			elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
				ANIM = "Walk"
				if ATTACK == false then

					RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0*SIZE- 0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
					RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.81*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(238.55+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(333.98+0 * COS(SINE / 1))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
					LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5*SIZE-0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1), 0*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(320.96+0 * COS(SINE / 33)), RAD(0+0 * COS(SINE / 33)), RAD(0+11 * COS(SINE / 33))) * LEFTSHOULDERC0, 1 / Animation_Speed)
					RightHip.C0 = Clerp(RightHip.C0, CF(0.5*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
					LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5*SIZE+0 * COS(SINE / 1), -1*SIZE+0 * COS(SINE / 1), 0.5*SIZE+0 * COS(SINE / 1)) * ANGLES(RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1)), RAD(0+0 * COS(SINE / 1))), 1 / Animation_Speed)
				end
			end
			unanchor()
			Humanoid.MaxHealth = 5e7
			Humanoid.Health = 5e7
			Humanoid.Name = "BigBoie"
			if Rooted == false then
				Disable_Jump = false
				Humanoid.WalkSpeed = Speed
			elseif Rooted == true then
				Disable_Jump = true
				Humanoid.WalkSpeed = 0
			end
			for _, c in pairs(Character:GetChildren()) do
				if c.ClassName == "Part" then
					c.Material = "SmoothPlastic"
					if c:FindFirstChildOfClass("ParticleEmitter") then
						c:FindFirstChildOfClass("ParticleEmitter"):remove()
					end
					if c == Torso or c.Name == "Muscle" then
						c.BrickColor = BRICKC"Bright blue"
					elseif c == RightLeg or c == LeftLeg then
						c.BrickColor = BRICKC"Br. yellowish green"
					else
						c.BrickColor = BRICKC"Bright yellow"
					end
					if c == Head then
						if c:FindFirstChild("face") then
							c.face.Texture = "http://www.roblox.com/asset/?id=145914523"
						end
					end
				elseif c.ClassName == "CharacterMesh" or c.ClassName == "Accessory" or c.Name == "Body Colors" then

				elseif (c.ClassName == "Shirt" or c.ClassName == "Pants") and c.Name ~= "Cloth" then

				end
			end
			sick.SoundId = "rbxassetid://2849483221"
			sick.Looped = true
			sick.Pitch = 1
			sick.Volume = 1
			sick:Resume()
			sick.Parent = Torso
			Humanoid.JumpPower = 50
		end
	end
end)

UICorner_20.Parent = Katana

PrisonLife.Name = "PrisonLife"
PrisonLife.Parent = ScreenGui
PrisonLife.Active = true
PrisonLife.BackgroundColor3 = Color3.fromRGB(52, 52, 52)
PrisonLife.Position = UDim2.new(0.642666936, 0, 0.171309188, 0)
PrisonLife.Size = UDim2.new(0, 214, 0, 440)
PrisonLife.Visible = false

UICorner_21.Parent = PrisonLife

Guns.Name = "Guns"
Guns.Parent = PrisonLife
Guns.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Guns.Position = UDim2.new(0.0327102803, 0, 0.215909094, 0)
Guns.Size = UDim2.new(0, 200, 0, 50)
Guns.Font = Enum.Font.SourceSansSemibold
Guns.Text = "Give all guns"
Guns.TextColor3 = Color3.fromRGB(255, 255, 255)
Guns.TextSize = 19.000
Guns.MouseButton1Down:connect(function()
	-- Script generated by SimpleSpy - credits to exx#9394

	local args = {
		[1] = workspace.Prison_ITEMS.giver:FindFirstChild("AK-47").ITEMPICKUP
	}

	workspace.Remote.ItemHandler:InvokeServer(unpack(args))
	-- Script generated by SimpleSpy - credits to exx#9394

	local args = {
		[1] = workspace.Prison_ITEMS.giver:FindFirstChild("M9").ITEMPICKUP
	}

	workspace.Remote.ItemHandler:InvokeServer(unpack(args))
	-- Script generated by SimpleSpy - credits to exx#9394

	local args = {
		[1] = workspace.Prison_ITEMS.giver:FindFirstChild("M4A1").ITEMPICKUP
	}

	workspace.Remote.ItemHandler:InvokeServer(unpack(args))
	-- Script generated by SimpleSpy - credits to exx#9394

	local args = {
		[1] = workspace.Prison_ITEMS.giver:FindFirstChild("Riot Shield").ITEMPICKUP
	}

	workspace.Remote.ItemHandler:InvokeServer(unpack(args))
	-- Script generated by SimpleSpy - credits to exx#9394

	local args = {
		[1] = workspace.Prison_ITEMS.giver:FindFirstChild("Remington 870").ITEMPICKUP
	}

	workspace.Remote.ItemHandler:InvokeServer(unpack(args))
	-- Script generated by SimpleSpy - credits to exx#9394

	local args = {
		[1] = workspace.Prison_ITEMS.single.Hammer.ITEMPICKUP
	}

	workspace.Remote.ItemHandler:InvokeServer(unpack(args))
	-- Script generated by SimpleSpy - credits to exx#9394

	local args = {
		[1] = workspace.Prison_ITEMS.single:FindFirstChild("Crude Knife").ITEMPICKUP
	}

	workspace.Remote.ItemHandler:InvokeServer(unpack(args))
end)

UICorner_22.Parent = Guns

TextLabel_4.Parent = PrisonLife
TextLabel_4.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_4.BackgroundTransparency = 1.000
TextLabel_4.BorderSizePixel = 0
TextLabel_4.Position = UDim2.new(0.0327102803, 0, 0.043181818, 0)
TextLabel_4.Size = UDim2.new(0, 200, 0, 50)
TextLabel_4.Font = Enum.Font.SourceSansSemibold
TextLabel_4.Text = "Syntrap Prison Life"
TextLabel_4.TextColor3 = Color3.fromRGB(245, 245, 245)
TextLabel_4.TextSize = 22.000

Frame_4.Parent = PrisonLife
Frame_4.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
Frame_4.Size = UDim2.new(0, 214, 0, 19)

UICorner_23.Parent = Frame_4

Frame_5.Parent = Frame_4
Frame_5.BackgroundColor3 = Color3.fromRGB(52, 52, 52)
Frame_5.Position = UDim2.new(-0.00172694027, 0, 23.6209507, 0)
Frame_5.Size = UDim2.new(0, 214, 0, 48)

UICorner_24.Parent = Frame_5

PrisonBack.Name = "PrisonBack"
PrisonBack.Parent = Frame_4
PrisonBack.BackgroundColor3 = Color3.fromRGB(52, 52, 52)
PrisonBack.BorderColor3 = Color3.fromRGB(52, 52, 52)
PrisonBack.Position = UDim2.new(0.392523348, 0, 23.7788486, 0)
PrisonBack.Size = UDim2.new(0, 46, 0, 42)
PrisonBack.Font = Enum.Font.SourceSansSemibold
PrisonBack.Text = "Back"
PrisonBack.TextColor3 = Color3.fromRGB(255, 255, 255)
PrisonBack.TextSize = 19.000
PrisonBack.MouseButton1Down:connect(function()
	PrisonLife.Visible = false 
	Selection.Visible = true 
end)

UICorner_25.Parent = PrisonBack

Punch.Name = "Punch"
Punch.Parent = PrisonLife
Punch.Active = false
Punch.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Punch.Position = UDim2.new(0.0327102803, 0, 0.356818229, 0)
Punch.Size = UDim2.new(0, 200, 0, 50)
Punch.Font = Enum.Font.SourceSansSemibold
Punch.Text = "Super Punch"
Punch.TextColor3 = Color3.fromRGB(255, 255, 255)
Punch.TextSize = 19.000
Punch.MouseButton1Down:connect(function()
	mainRemotes = game.ReplicatedStorage meleeRemote = mainRemotes['meleeEvent'] mouse = game.Players.LocalPlayer:GetMouse() punching = false cooldown = false function punch() cooldown = true local part = Instance.new("Part", game.Players.LocalPlayer.Character) part.Transparency = 1 part.Size = Vector3.new(5, 2, 3) part.CanCollide = false local w1 = Instance.new("Weld", part) w1.Part0 = game.Players.LocalPlayer.Character.Torso w1.Part1 = part w1.C1 = CFrame.new(0,0,2) part.Touched:connect(function(hit) if game.Players:FindFirstChild(hit.Parent.Name) then local plr = game.Players:FindFirstChild(hit.Parent.Name) if plr.Name ~= game.Players.LocalPlayer.Name then part:Destroy() for i = 1,100 do meleeRemote:FireServer(plr) end end end end) wait(1) cooldown = false part:Destroy() end mouse.KeyDown:connect(function(key) if cooldown == false then if key:lower() == "f" then punch() end end end)
end)

UICorner_26.Parent = Punch

Tazer.Name = "Tazer"
Tazer.Parent = PrisonLife
Tazer.Active = false
Tazer.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
Tazer.Position = UDim2.new(0.0327102803, 0, 0.50000006, 0)
Tazer.Size = UDim2.new(0, 200, 0, 50)
Tazer.Font = Enum.Font.SourceSansSemibold
Tazer.Text = "Tazer Bypass"
Tazer.TextColor3 = Color3.fromRGB(255, 255, 255)
Tazer.TextSize = 19.000
Tazer.MouseButton1Down:connect(function()
	game.Players.LocalPlayer.Character.ClientInputHandler.Disabled = true
	game.Players.LocalPlayer.CharacterAdded:connect(function()
		game.Workspace:WaitForChild(game.Players.LocalPlayer.Name)
		game.Players.LocalPlayer.Character.ClientInputHandler.Disabled = true
	end)
end)

UICorner_27.Parent = Tazer

-- Scripts:

local function CYJSD_fake_script() -- Tip.LocalScript 
	local script = Instance.new('LocalScript', Tip)

	wait(0.1)
	bar1.Visible = true 
	wait(1)
	bar2.Visible = true 
	wait(1)
	bar3.Visible = true 
	wait(0.1)
	bar4.Visible = true 
	wait(1)
	bar5.Visible = true  
	wait(0.1)
	MainLoad.Visible = false 
	wait (0.1)
	game:GetService("StarterGui"):SetCore("SendNotification", {
		Title = "Loaded Syntrap!",
		Text = ""
	})
	wait (0.1)
	local s = Instance.new("Sound")

s.Name = "Sound"
s.SoundId = "http://www.roblox.com/asset/?id=5388706560" -- Type your music ID here
s.Volume = 10
s.Pitch = 1
s.Looped = false 
s.archivable = false

s.Parent = game.Workspace

wait(0)

s:play()
	Selection.Visible = true 
end
coroutine.wrap(CYJSD_fake_script)()
local function BCNKFBS_fake_script() -- Selection.d 
	local script = Instance.new('LocalScript', Selection)

	script.Parent.Draggable = true;
end
coroutine.wrap(BCNKFBS_fake_script)()
local function PXDKHL_fake_script() -- Fescript.c 
	local script = Instance.new('LocalScript', Fescript)

	script.Parent.Draggable = true;
	
end
coroutine.wrap(PXDKHL_fake_script)()
local function GLGCAQ_fake_script() -- PrisonLife.a 
	local script = Instance.new('LocalScript', PrisonLife)

	script.Parent.Draggable = true;
end
coroutine.wrap(GLGCAQ_fake_script)()
	end
end
